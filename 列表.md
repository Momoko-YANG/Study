
- 二次遍历：第一次遍历得到某辅助指标，第二次利用该指标完成任务
- 相邻比较
- 互换


## Python常用操作

- 从列表list中找出与目标值第一个匹配项的索引
```python
a = 0
list.index(a)
```
- python中使用列表实现队列
```python
import collections

q = list.pop(0) # index=0, pop后，q=list[0], list=[剩余元素]
# list.remove(element)
# list.append(element)

q = collections.deque()
q.popleft()
q.pop() # 从right pop
q.append(1)
q.append(0, 1)
q.extend(list) # 两个list concat, 不返回
```
- 从某个位置插入元素
```python
# 通过不断往0位置插入手工翻转一个list
# 时间复杂度是 O(n)，插入操作需要将列表中所有现有的元素向右移动一个位置，以便为新元素腾出空间
list.insert(0, num)
```
- 列表排序
```python
l = sorted(l)
l = sorted(l, key = lambda x : x[0])
l = sorted(l, reverse = True)

l.sort() # 注意这里是in-place

# 多个sorting key
array.sort(key = lambda element:(element[1], element[2]), reverse = True) 

# 双list排 或者直接 循环时排
[x for _, x in sorted(zip(Y,X), key = lambda pair:pair[0])]

# 自定义
cars = ['Ford', 'Mitsubishi', 'BMW', 'VM']

def myFunc(e):
    return len(e)
    
cars.sort(reverse = True, key = myFunc)
```
- 索引倒序遍历
```python
range(len(nums)-1, -1, -1)
```
- 列表索引
```python
# 左闭右开
# 从右边取，注意为0会取全体值是否是想要的
list[-1:] # 取最后一个
list[-0:] # 取全体list
list[::2] # 每间隔2个取
```
- deque
```python
# BFS常用
# my_deque.reverse() 不会创建新的内存空间
from collections import deque

queue = deque([1,2,3])
queue.append(4)
queue.popleft()
```
- 定义二维列表
```python
matrix = [[0 for _ in range(col)] for _ in range(row)]
matrix1 = [[0] * col for _ in range(row)]

# 错误，都是引用导致值相同
[[0] * col] * row
```
- 二维列表转置
  假设我们有这样一个二维列表
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
```
   转置后目标是得到：
```python
[[1, 4, 7], 
 [2, 5, 8], 
 [3, 6, 9]]
```

 1. 使用 `zip()` 函数和列表推导式 (最简洁)
 ```python
 matrix = [[1,2,3], [4,5,6], [7,8,9]]
 
 # 使用 zip 将列打包，然后用 list() 将元组转为列表
 transposed_matrix = [list(row) for row in zip(*matrix)]
 print(transposed_matrix)
 ```

2. 使用嵌套循环
```python
matrix = [[1,2,3], [4,5,6], [7,8,9]]

# 获取原始矩阵的行数和列数
rows = len(matrix)
cols = len(matrix[0])

# 创建一个用于存放结果的空矩阵
transposed_matrix = [[0 for _ in range(rows)] for _ in range(cols)]

# 遍历原始矩阵
for i in range(rows):
    for j in range(cols):
        transposed_matrix[j][i] = matrix[i][j]
        
print(transposed_matrix) 
``` 

   3. 使用`Numpy` 库
```python
import numpy as np

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# 将普通列表转换为 NumPy 数组
np_matrix = np.array(matrix)

# 使用 .T 属性或 transpose() 方法进行转置
transposed_list = np_matrix.T
# 或者 transposed_matrix = np.transpose(np_matrix)

# 如果需要，可以再转回 Python 的二维列表
transposed_list = transposed_matrix.tolist()

print(transposed_list)
```

- 个位是否为1 
```python
x % 10 == 1
```
- heapq堆的操作
```python
import heapq

data = [2,3,5,1]
heapq.heapify(data)
heapq.heappush(data, 6)
print(heapq.heappop(data))
```
- 链表循环内容涉及两个节点判断时
```python
# 根据head / head.next / head & head.next 来决定迭代终点
while head is not None and head.next is not None:
    pass
```
- 字符串前的空格
```python
s.strip()
```
- 字符串
```python
# ord
ord(s[0]) / s[0].isdigit()

# 小写
s.lower()
```
- 两层循环中的break，break的是相应层的循环。
- 多个条件判断时，条件是有先后顺序的。是否月结和是否符合条件可以写在一起。
```python
# 正确
while s[l] == s[r] and l >= 0 and r < len(s):

# 错误
while l >= 0 and r < len(s) and s[l] == s[r]:
```
- for循环：提前已知遍历的所有元素；while循环：根据循环过程来决定所有遍历元素。
- 最小与最大
```python
float('inf')
float('-inf')
```
- flag来交替
The goal of LeetCode #280, "Wiggle Sort," is to reorder an array in-place so its elements follow a "wiggle" pattern: `nums[0] <= nums[1] >= nums[2] <= nums[3] >= ...`.
For example, given the input `[3, 5, 2, 1, 6, 4]`, a valid wiggle-sorted output would be `[3, 5, 1, 6, 2, 4]` because:
     3 <= 5
     5 >= 1
     1 <= 6
     6 >= 2
     2 <= 4
There are two common ways to solve this: a simple sorting method and a more efficient one-pass greedy approach.
```python
# leetcode 280.Wiggle Sort
def wiggleSort(nums: list[int]) -> None:

```
